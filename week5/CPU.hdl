// * 조합칩은 맘대로 쓸 수 있다는 사실..
CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
        // jmpFlag
        // jmpAddress[0]=
        // jmpAddress[1..15]=
        Or(a=instruction[15], b=false, out=isCInstruction);
        Not(in=isCInstruction, out=isAInstruction);
        
        // prevent to execute when isAInstruction. below instruction parser executes only when isCInstruction.
        Or16(a[0..2]=instruction[3..5], b=false, out[0..2]=dBits); // dBits Count = 3
        Or16(a[0..5]=instruction[6..11], b=false, out[0..5]=cBits); // cBits Count = 6
        Or(a=instruction[12], b=false, out=aBit); // aBit Count = 1

        WhereToSave(d=dBits, saveA=saveA, saveD=saveD, saveM=saveM);

        // Decoder
        // isCInstruction

        // a
        // c[0..5]
        // d[0..2]
        // j[0..2]
        Jumper(in=aluResult, j=instruction[0..2], jmpFlag=jmpFlag);

        // AInstructionParser

        // CInstructionParser

        // aRegister
        // in=, load=isAInstruction,
        Mux16(a[0..14]=instruction[0..14], a[15]=false, b=aluResult, sel=isCInstruction, out=aluResultOrValue);
        // in[0..14]=instruction[0..14],
        ARegister(in=aluResultOrValue, load=saveA, out=ARegisterOut);

        // dRegister
        DRegister(in=aluResult, load=saveD, out=DRegisterOut);

        Mux16(a=ARegisterOut, b=inM, sel=aBit, out=ARegisterOutOrInM); // aBit=0, sel a(ARegisterOut); aBit=1, sel m(inM[16]);
        // no=cBits[0], f=cBits[1], ny=cBits[2], zy=cBits[3], nx=cBits[4], zx=cBits[5],
        ALU(x=DRegisterOut, y=ARegisterOutOrInM, no=instruction[6], f=instruction[7], ny=instruction[8], zy=instruction[9], nx=instruction[10], zx=instruction[11], out=aluResult);

        Not(in=jmpFlag, out=notJmpFlag);
        PC(in=ARegisterOut, load=jmpFlag, inc=notJmpFlag, reset=reset, out[1..15]=pc);

        Or(a=saveM, b=false, out=writeM);
        Or16(a=aluResult, b=false, out=outM);
        Or16(a=ARegisterOut, b=false, out[0..14]=addressM);
}